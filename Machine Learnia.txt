Machine Learnia : https://www.youtube.com/watch?v=82KLS2C_gNQ&list=PLO_fdPEVlfKqMDNmCFzQISI2H_nJcEDJq
Cours : Python

Telecharger Python et installer sur www.anaconda.com/   (Anaconda est une distrib de Python)
Lancer Anaconda et installer les Interfaces : Spyder et Jupyter
            --> Spyder : Editeur de code standard avec console

-------- Variables et Fonction ------------------

#Arithmetic

    print(x + y)
    print(x - y)
    print(x * y)
    print(x / y)
    print(x ** y)   : fonction puissance

# Comparison

    print(x <= y)
    print(x >= y)
    print(x == y)
    print(x != y)

# Logic

    print(False & True) # AND
    print(False | True) # OR
    print(False True) # XOR

Fonctions 

    f = lambda x : x**2  < ---- Equivalant à f(x)=x² . Lambda adapté pour les fonctions maths
    f = lambda x,y : x**2 + y

On utilise plus les fonctions en programmation pour les fonctionnalités. 
NB : Les instructions avant le prochain saut de ligne font partir de la fonction

    def e_potential (mass, height, g=9.81): 
        E = mass * height * g
        print(E, 'Joules')
        return E

    result = e_potential (mass=80, height=5)
    result = e_potential (mass=80, height=5, g=6.7)

Exo: Pour retourner true or false si l'energie potentielle est < à une valeur limite :

    def e_potential_limit(mass, height, limit, g=9.81):
        E = mass * height * g
        #print(E)
        return E < limit

    e_potential_limit(5,10,6000) < ---- retourne true


    def fibonacci(n):
        a = 0
        b = 1
        while a < n:
            print(a)
            a, b = b, a+b
        
---------- Les structures de condition ----------

Instruction : if --------

    def signe(x):
        if x > 0:
        print(x, 'positive')
        elif x == 0:
        print(x, 'nul)
        else:
        print(x, 'negative')


Instruction : For ------------

    for i in range(10):
        print(i)
    
NB : range() -> génère une sequence de nombre que l'on peut parcourir
Example: range(10) -> 0, 1, 2, 3, 4, 5, 6, 7, 8, 9

range() prend en réalité 3 arguments: range(debut, fin, pas)
Example:

    for element in range(5, 10, 2):
        print(element)

    5
    7
    9

range() peut avoir des arguments négatifs qui inversent les sens de parcours

    for element in range(10, -10, -3):
        signe (element)

    10 positif
     7 positif
     4 positif
     1 positif
    -2 negatif
    -5 negatif
    -8 negatif

Instruction : While ------------

    x = 0

    while x<3:
        print(x)
        x += 1

    0
    1
    2
    3

-------- Les Sequences : Listes, Tuples, Strings ------------------ 

Sequence : ensemble d'elements ordonnés. Chaque élt a un indexe

# Lists 

    list_1= [1, 4, 2, 7, 35, 84]
    cities = ['Paris', 'Berlin', 'London', 'Brussels']
    list_2= [list_1, cities]
    list_3 = [] 

# Tuple
    1 = (1, 2, 6, 1, 7)

# String
    prenom = 'Nicolas'


#INDEXING

    print(cities[0]) # first element = index 0
    print(cities[1]) # second element = index 1
    print(cities[-1]) # last element
    print(cities[-2]) # before last

# Slicing

Permet de récupérer des elts en indiquant : debut:fin:pas

    print cities = [0:3] (or cities = [:3] quand on commence par 0)     --> 'Paris', 'Berlin', 'London'
    print cities = [2:]  --> 'London', 'Brussels'
    print cities = [1:3] --> 'Berlin', 'London'
    print cities = [::2] --> 'Paris', 'London'
    print cities = [::-1]--> 'Brussels''London','Berlin','Paris'  
    
    print(prenom[:3]) --> Nic
    
    - Ajout en fin de liste
    cities.append('Dublin')     --> 'Paris', 'Berlin', 'London', 'Brussels', 'Dublin'
    
    - Insertion à une position donnée
    cities.insert(2, 'Madrid')  --> 'Paris', 'Berlin', 'Madrid', 'London', 'Brussels', 'Dublin' NB: Index 2 = 3e position

    - Extend : Pour ajouter une liste à la fin d'une liste existante 
    
    cities_2 = ['Amsterdam', 'Rome']
    cities.extend(cities_2) --> cities = ['Paris', 'Berlin', 'Madrid', 'London', 'Brussels', 'Dublin','Amsterdam', 'Rome']

    - Voir le nombre d'elts dans la liste 
    len(cities) --> 8
    
    - Trier une liste :  
    len(cities).sort()  --> alphabetique ou numerique du plus grand au plus    
    len(cities).sort(reverse=true)   --> Tri inverse alphabetique ou numerique
    
    - Compter les occurences :
    cities.count('Paris') = 1
    
    - Voir autres methodes tels que : pop, clear, remove ...
    
    - If : pour Vérifier si un elt est dans une liste :
    
        if 'Belfast' in cities:
            print('Yes')
        else:
            print('Non')

        --> Non

    - For : Pour parcourir une liste 
    
        for i in (cities): 
            print(i)

    
    - For : Pour parcourir une liste et afficher les indexes:
    
        for index, value in enumerate(cities): 
            print(index, value)

        0 Rome
        1 Paris
        2 Madrid   
        ...
        
    - zip : pour parcourir et afficher les données de 2 listes en parallèle. Elle s'arrête là où la liste la plus courte 
            prend fin

        for a, b in zip (villes, liste_2): 
            print(a, b)    
    
        Rome 2
        Paris 3
        Madrid 23
        ...
 
Exo : Return a list containing the fibonacci sequence

    def fibonacci(n):
        
        a = 0
        b = 1
        fib = [a]
        while b < n:
            a, b = b, a+b
            fib.append(a)
        return fib
        
        print(fibonacci(1000))
 
 ---- Les Dictionnaires -------------------------------

Ici les valeurs ne sont pas ordonnées (pas d''indexes) mais des clés. C'est une association "clé : valeur " .
La clé doit être unique

    translation { 
        "dog": "dog",
        "chat" : "cat",
        "mouse": "mouse",
        "bird": "bird" 
    }

    inventaire = {
        "bananes":5000,
        "pommes":2094,
        "poires":412809,
        "cerises":2893
        }

- On peut nester des dicts :

    dictionary_3 = { 
        "dict_1": translation, 
        "dict_2": inventory 
        }


- Certains utilisent les dicts pour créer leur réseau de neurones (voir plus loin)
    
    import numpy as np

    parameters = { 
        "W1": np.random.randn(10, 100),
        "b1": np.random.randn(10, 1),
        "W2" : np.random.randn(10, 10),
        "b2": np.random.randn(10, 1)
        }
    
- Afficher les données du dict :
    inventaire.values()  -->  dict_values([5000, 2094, 412809, 2893])
   
 
dict_values([5000, 2094, 412809, 2893])

- Afficher les clés : 
    inventaire.keys() -->  dict_keys(['bananes', 'pommes', 'poires', 'cerises'])

- Longueur dict :
    len(inventaire)  --> 4

- Ajouter un nouvel élément au dict :
    inventaire ["abricots"] = 4902      -->  Pas besoin d'ordre et d'indexe ici car pas une séquence

     -->   inventaire = {
                'bananes':5000,
                'pommes': 2094,
                'poires':412809,
                'cerises':2893,
                'abricots': 4902} 
    
- Autres méthodes :

        inventory.
                clear
                copy
                fromkeys
                get
                items
                keys
                pop
                popitem
                setdefault
                update

- get : permet d'afficher une valeur par défaut si on ne retrouve pas l'elt recherché dans dict :   
 
     print(inventaire.get('peches'))    --> None    : valeur non trouvée et None est renvoyé
     print(inventaire.get('peches',1))  --> 1       : valeur non trouvée donc 1 est renvoyé
     print(inventaire.get('cerises',1)) --> 2893    : valeur trouvée et renvoyée
    

- fromkeys : Permet de créer un dict à partir d'une liste forunie

    list_1 = ('Paris', 'London', 'Brussels')

    inventory.fromkeys(list_1)
    {'Paris': None, 'London': None, 'Brussels': None }  --> None est la valeur associées aux clés du dict

    inventory.fromkeys(list_1, 'default')
    {'Paris': 'default', 'London': 'default', 'Brussels':'default'} --> 'default' est la valeur associées aux clés du dict
    
- pop : 1. Retire un élt de dict ou d''une liste et 2. retourne la valeur de l''élt en sortie

    fruits = inventaire.pop('abricots') -->  fruits = 4902 

     -->   inventaire = {
                'bananes':5000,
                'pommes': 2094,
                'poires':412809,
                'cerises':2893
                }     
    
- For : Pour afficher un dict :

    for i in inventaire: 
        print(i)

        bananes 
        pommes 
        poires 
        cerises   

    for i in inventaire.values():   -->  Pour afficher les valeurs
        print(i)

        5000
        2094
        412809
        2893  
    
    for k, v in inventaire.items(): -->  Pour afficher les clés et les valeurs
        print(k, v)

        bananes 5000
        pommes  2094 
        poires  412809
        cerises 2893    
    
 
----------- Built-in function - Fonctions de base -------------------------

docs.python.org/3/library/functions.html#len


- abs : valeur absolue
    x = -2 -->  abs(x) = 2

- round
    x = 3,14 -->  round(x) = 3

- max et min

    liste_1 = [0, 23, 14, -19]
    max(liste_1) = 23
    min(liste_1) = -19
    len(list_1) = 4

- sum des elts :
    sum(list_1) = 18

- all et any :

    all : retourne True quand tous les éléments de la liste sont égaux à True
    any : retourne True quand au moins un élément de la liste est égal à True

    list_2 = [True, True, False] 
        all (list_2) --> False
        any (list_2) --> True

    any (list_1) --> True  : car au moins un élt n'est pas égal à 0

 ----- Conversion de types 

    x = 10 --> type(x) est int
    x = str(x) --> type(x) est str
    
    x = '10' --> type(x) est str
    x = int(x) --> type(x) est int
    
    x=10 --> float(x) = 10.0
    type(float(x)) est float
    
    list_1 = [0, 61, 63, 243]
    tuple(list_1) --> (0, 61, 63, 243)

    tuple_1 = tuple(list_1) 
    list(tuple_1) --> [0, 61, 63, 243]
    
 - Convert dict en liste : 
    list(inventaire.keys()) --> ['bananes', 'pommes', 'poires']

 - Fonction binaire, Oct, hexa 
   bin(15) --> '0b1111'
   oct(15) --> '0o17'
   hex(15) --> '0xf'
   
- Input : saisir des données

    x = input('enter a number : ')
    enter a number : 5      --> x = '5' de type str

- Fonction format()

    x = 25
    ville = 'Paris'

    message = "la température est de {} degC a {}".format(x, ville)
    print(message) -->  la température est de 25 deg a Paris

    message = f"la température est de {x} degC a {ville}"
    print(message) -->  la température est de 25 deg a Paris

Exple : 

    import numpy as np

    parameters = { 
            "W1": np.random.randn(2, 4),
            "b1": np.zeros((2, 1)),
            "W2": np.random.randn(2, 2),
            "b2": np.zeros((2, 1))
            }

    for i in range(1,3):
        print("couche", i)
        print(parameters["W{}".format(i)])  --> même résultat avec print(parameters["W"+str(i)])

        couche 1 

        [-0.61807457 0.89824653 -0.57570348 0.16627105]
        [-1.07827718 -2.56498375 -0.16742567 -1.0747071 ]]

        couche 2 

        [[-0.91408156 0.83830415][0.15802067 -0.13057656]]


- Fonction open : gestion des fichiers 

    open file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
    
     Character      Meaning

        'r'         open for reading (default)
        'w'         open for writing, truncating the file first
        'x'         open for exclusive creation, failing if the file already exists
        'a'         open for writing, appending to the end of the file if it exists
        'b'         binary mode
        't'         text mode (default)

Exemple : 

   - Ouvrir et ecrire dans le fichier :
   
    f = open('file.txt', 'w')
    f.write('hello')
    f.close()

   - Ouvrir et lire dans le fichier :
   
    f = open('file.txt', 'r')
    print(f.read())                        -->    'hello'
    f.close()

    Dans la pratique :
    with open('fichier.txt', 'r') as f:
        print(f.read())                 --> 'hello'   NB: Pas besoin de f.close() car python ferme automatiquement le fichier

Exemple : Ecrire dans un fichier, le carré de nombre de 0 à 10 : 

    with open('fichier.txt', 'w') as f:
        for i in range(10):
            f.write("{}^2 = {} \n".format(i, i**2))   --> format est utile ici car write prend 1 seul arg de type str
    
        0^2 = 0
        1^2 = 1
        2^2 = 4
        3^2 = 9
        4^2 = 16
        5^2 = 25
        6^2 = 36
        7^2 = 49
        8^2 = 64
        9^2 = 81
 
 